{"version":3,"sources":["Main/parseTable.js","Main/firstfollow.js","Main/ll1-parser.js","App.js","serviceWorker.js","index.js"],"names":["Table","EPSILON","buildParsingTable","grammar","parsingTable","k","production","LHS","getLHS","RHS","getRHS","productionNumber","Number","getFirstSetOfRHS","forEach","terminal","followSets","split","replace","firstSets","getNonTerminals","nonTerminals","Object","keys","symbol","push","getTerminals","terminals","table","this","props","console","log","className","scope","map","key","React","Component","FirstFollow","buildFirstSets","buildSet","firstOf","first","isTerminal","productionsForSymbol","getProductionsForSymbol","i","length","productionSymbol","firstOfNonTerminal","merge","buildFollowSets","followOf","follow","START_SYMBOL","productionsWithSymbol","getProductionsWithSymbol","followIndex","indexOf","followSymbol","firstOfFollow","builder","test","to","from","exclude","printGrammar","printSet","name","set","setElement","index","firstSymbol","convertSets","newSet","tempList","firstEntry","startSymbol","newFirsts","newFollows","LL1","state","show","transitions","ll1","lhsRef","createRef","rhsRef","startSymbolRef","colSpan","placeholder","ref","id","type","onClick","current","value","setState","alert","defaultValue","onKeyDown","e","keyCode","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.91ff629e.chunk.js","sourcesContent":["/* eslint-disable no-loop-func */\nimport React from 'react';\n\nclass Table extends React.Component {\n    EPSILON = 'ε';\n\n    buildParsingTable = (grammar) => {\n        var parsingTable = {};\n\n        for (var k in grammar) {\n            var production = grammar[k];\n            var LHS = this.getLHS(production);\n            var RHS = this.getRHS(production);\n            var productionNumber = Number(k);\n\n            // Init columns for this non-terminal.\n            if (!parsingTable[LHS]) {\n                parsingTable[LHS] = {};\n            }\n\n            // All productions goes under the terminal column, if\n            // this terminal is not epsilon.\n            if (RHS !== this.EPSILON) {\n                this.getFirstSetOfRHS(RHS).forEach((terminal) => {\n                    parsingTable[LHS][terminal] = productionNumber;\n                });\n            } else {\n                // Otherwise, this ε-production goes under the columns from\n                // the Follow set.\n                this.followSets[LHS].forEach(function (terminal) {\n                    parsingTable[LHS][terminal] = productionNumber;\n                });\n            }\n        }\n\n        return parsingTable;\n    }\n\n    getLHS = (production) => {\n        return production.split('->')[0].replace(/\\s+/g, '');\n    }\n\n    getRHS = (production) => {\n        return production.split('->')[1].replace(/\\s+/g, '');\n    }\n\n    getFirstSetOfRHS = (RHS) => {\n\n        // For simplicity, in this educational parser, we assume that\n        // the first symbol (if it's a non-terminal) cannot produces `ε`.\n        // Since in real parser, we need to get the First set of the whole RHS.\n        // This means, that if `B` in the production `X -> BC` can be `ε`, then\n        // the First set should of course include First(C) as well, i.e. RHS[1], etc.\n\n        // That is, in a real parser, one usually combines steps of building a\n        // parsing table, First and Follow sets in one step: when a parsing table\n        // needs the First set of a RHS, it's calculated in place.\n\n        // But here we just return First of RHS[0].\n\n\n        return this.firstSets[RHS[0]];\n    }\n\n\n    getNonTerminals = () => {\n        // Small case letters in FirstSets\n        var nonTerminals = [];\n        Object.keys(this.firstSets).forEach((symbol) => {\n            if (symbol >= 'A' && symbol <= 'Z')\n                nonTerminals.push(symbol)\n        })\n        \n        return nonTerminals\n    }\n    getTerminals = () => {\n        // Small case letters in FirstSets\n        var terminals = [];\n        Object.keys(this.firstSets).forEach((symbol) => {\n            if (!(symbol >= 'A' && symbol <= 'Z'))\n                terminals.push(symbol)\n        })\n        return terminals\n    }\n\n    // createTable = () => {\n\n    // }\n\n\n    // grammar = {\n    //     1: 'E -> TX',\n    //     2: 'X -> +TX',\n    //     3: 'X -> ε',\n    //     4: 'T -> FY',\n    //     5: 'Y -> *FY',\n    //     6: 'Y -> ε',\n    //     7: 'F -> a',\n    //     8: 'F -> (E)',\n    // };\n\n    // firstSets = {\n    //     'E': ['a', '('],\n    //     'T': ['a', '('],\n    //     'F': ['a', '('],\n    //     'a': ['a'],\n    //     '(': ['('],\n    //     'X': ['+', 'ε'],\n    //     '+': ['+'],\n    //     'Y': ['*', 'ε'],\n    //     '*': ['*'],\n    // };\n\n    // followSets = {\n    //     'E': ['$', ')'],\n    //     'X': ['$', ')'],\n    //     'T': ['+', '$', ')'],\n    //     'Y': ['+', '$', ')'],\n    //     'F': ['*', '+', '$', ')'],\n    // };\n\n    grammar = {};\n\n    firstSets = {};\n\n    followSets = {};\n\n    table = {};\n\n    render() {\n        this.grammar = this.props.grammar;\n        this.firstSets = this.props.firstSets;\n        this.followSets = this.props.followSets;\n\n        console.log(\"TABLE\")\n        this.table = this.buildParsingTable(this.grammar);\n        console.log(this.table);\n\n        var terminals = this.getTerminals();\n        console.log(terminals)\n        var nonTerminals = this.getNonTerminals();\n\n        return (\n            <div>\n                <table className=\"table table-hover\">\n                    <thead>\n                        <tr>\n                            <th scope=\"col\">Symbols</th>\n                            {terminals.map((symbol) => {\n                                return <th scope=\"col\" key={symbol}>{symbol}</th>\n                            })}\n                        </tr>\n                    </thead>\n                    <tbody>\n                        {\n                            Object.keys(this.table)\n                                .map((symbol) => {\n                                    return <tr key={symbol}>\n                                        <th scope=\"row\">{symbol}</th>\n                                        {terminals.map((terminal) => {\n                                            return <td key={terminal}>\n                                                {\n                                                    this.table[symbol][terminal]\n                                                        ?   this.grammar[this.table[symbol][terminal]]\n                                                        :   \"---\"\n                                                }\n                                            </td>\n                                        })}\n                                    </tr>\n                                })\n                        }\n                        {/* {terminals.map((symbol) => {\n                            return <tr key={symbol}>\n                                <th scope=\"row\">{symbol}</th>\n                                {nonTerminals.map((symbol, index) => {\n                                    return <td key={index}>{index}</td>\n                                })}\n                            </tr>\n                        })} */}\n                    </tbody>\n                </table>\n            </div>\n        );\n    }\n}\n\nexport default Table;","/* eslint-disable no-loop-func */\nimport React from 'react';\nimport Table from './parseTable';\n\nimport './firstfollow.css';\n\nclass FirstFollow extends React.Component {\n\n    buildFirstSets = (grammar) => {\n        this.firstSets = {};\n        this.buildSet(this.firstOf);\n    }\n\n    firstOf = (symbol) => {\n\n        // A set may already be built from some previous analysis\n        // of a RHS, so check whether it's already there and don't rebuild.\n        if (this.firstSets[symbol]) {\n            return this.firstSets[symbol];\n        }\n\n        // Else init and calculate.\n        var first = this.firstSets[symbol] = {};\n\n        // If it's a terminal, its first set is just itself.\n        if (this.isTerminal(symbol)) {\n            first[symbol] = true;\n            return this.firstSets[symbol];\n        }\n\n        var productionsForSymbol = this.getProductionsForSymbol(symbol);\n        for (var k in productionsForSymbol) {\n            var production = this.getRHS(productionsForSymbol[k]);\n\n            for (var i = 0; i < production.length; i++) {\n                var productionSymbol = production[i];\n\n                // Epsilon goes to the first set.\n                if (productionSymbol === this.EPSILON) {\n                    first[this.EPSILON] = true;\n                    break;\n                }\n\n                // Else, the first is a non-terminal,\n                // then first of it goes to first of our symbol\n                // (unless it's an epsilon).\n                var firstOfNonTerminal = this.firstOf(productionSymbol);\n\n                // If first non-terminal of the RHS production doesn't\n                // contain epsilon, then just merge its set with ours.\n                if (!firstOfNonTerminal[this.EPSILON]) {\n                    this.merge(first, firstOfNonTerminal);\n                    break;\n                }\n\n                // Else (we got epsilon in the first non-terminal),\n                //\n                //   - merge all except for epsilon\n                //   - eliminate this non-terminal and advance to the next symbol\n                //     (i.e. don't break this loop)\n                this.merge(first, firstOfNonTerminal, [this.EPSILON]);\n                // don't break, go to the next `productionSymbol`.\n            }\n        }\n\n        return first;\n    }\n\n    getProductionsForSymbol = (symbol) => {\n        var productionsForSymbol = {};\n        for (var k in this.grammar) {\n            if (this.grammar[k][0] === symbol) {\n                productionsForSymbol[k] = this.grammar[k];\n            }\n        }\n        return productionsForSymbol;\n    }\n\n    getLHS = (production) => {\n        return production.split('->')[0].replace(/\\s+/g, '');\n    }\n\n    getRHS = (production) => {\n        return production.split('->')[1].replace(/\\s+/g, '');\n    }\n\n    buildFollowSets = (grammar) => {\n        this.followSets = {};\n        this.buildSet(this.followOf);\n    }\n\n    followOf = (symbol) => {\n\n        // If was already calculated from some previous run.\n        if (this.followSets[symbol]) {\n            return this.followSets[symbol];\n        }\n\n        // Else init and calculate.\n        var follow = this.followSets[symbol] = {};\n\n        // Start symbol always contain `$` in its follow set.\n        if (symbol === this.START_SYMBOL) {\n            follow['$'] = true;\n        }\n\n        // We need to analyze all productions where our\n        // symbol is used (i.e. where it appears on RHS).\n        var productionsWithSymbol = this.getProductionsWithSymbol(symbol);\n        for (var k in productionsWithSymbol) {\n            var production = productionsWithSymbol[k];\n            var RHS = this.getRHS(production);\n\n            // Get the follow symbol of our symbol.\n            var symbolIndex = RHS.indexOf(symbol);\n            var followIndex = symbolIndex + 1;\n\n            // We need to get the following symbol, which can be `$` or\n            // may contain epsilon in its first set. If it contains epsilon, then\n            // we should take the next following symbol: `A -> aBCD`: if `C` (the\n            // follow of `B`) can be epsilon, we should consider first of `D` as well\n            // as the follow of `B`.\n\n            while (true) {\n\n                if (followIndex === RHS.length) { // \"$\"\n                    var LHS = this.getLHS(production);\n                    if (LHS !== symbol) { // To avoid cases like: B -> aB\n                        this.merge(follow, this.followOf(LHS));\n                    }\n                    break;\n                }\n\n                var followSymbol = RHS[followIndex];\n\n                // Follow of our symbol is anything in the first of the following symbol:\n                // followOf(symbol) is firstOf(followSymbol), except for epsilon.\n                var firstOfFollow = this.firstOf(followSymbol);\n\n                // If there is no epsilon, just merge.\n                if (!firstOfFollow[this.EPSILON]) {\n                    this.merge(follow, firstOfFollow);\n                    break;\n                }\n\n                this.merge(follow, firstOfFollow, [this.EPSILON]);\n                followIndex++;\n            }\n        }\n\n        return follow;\n    }\n\n    buildSet = (builder) => {\n        for (var k in this.grammar) {\n            builder(this.grammar[k][0]);\n        }\n    }\n\n    getProductionsWithSymbol = (symbol) => {\n        var productionsWithSymbol = {};\n        for (var k in this.grammar) {\n            var production = this.grammar[k];\n            var RHS = this.getRHS(production);\n            if (RHS.indexOf(symbol) !== -1) {\n                productionsWithSymbol[k] = production;\n            }\n        }\n        return productionsWithSymbol;\n    }\n\n    isTerminal = (symbol) => {\n        return !/[A-Z]/.test(symbol);\n    }\n\n    merge = (to, from, exclude) => {\n        exclude || (exclude = []);\n        for (var k in from) {\n            if (exclude.indexOf(k) === -1) {\n                to[k] = from[k];\n            }\n        }\n    }\n\n    printGrammar = (grammar) => {\n        console.log('Grammar:\\n');\n        for (var k in grammar) {\n            console.log('  ', grammar[k]);\n        }\n        console.log('');\n    }\n\n    printSet = (name, set) => {\n        console.log(name + ': \\n');\n        for (var k in set) {\n            console.log('  ', k, ':', Object.keys(set[k]));\n        }\n        console.log('');\n    }\n\n    setElement = (set) => {\n        return Object.keys(set).map((symbol, index) => {\n            return (\n                <tr key={symbol + index}>\n                    <th scope=\"row\">{index + 1}</th>\n                    <td>{symbol}</td>\n                    <td>{Object.keys(set[symbol]).map((firstSymbol) => {\n                        return firstSymbol + \" \"\n                    })}</td>\n                </tr>\n            )\n        })\n    }\n\n    // grammar = {\n    //     1: 'S -> F',\n    //     2: 'S -> (S + F)',\n    //     3: 'F -> a',\n    // };\n\n    \n    EPSILON = \"ε\";\n    \n    grammar = {}\n    firstSets = {};\n    followSets = {};\n\n    START_SYMBOL = '';\n\n    convertSets = (set) => {\n        // The sets have elements with their boolean true or false.\n        // Just want the elements\n        var newSet = {}\n        for (var symbol in set){\n            var tempList = [];\n            Object.keys(set[symbol]).forEach((firstEntry) => {\n                if (set[symbol][firstEntry])\n                    tempList.push(firstEntry)\n            })\n            newSet[symbol] = tempList;\n        }\n        return newSet;\n    }\n\n    render() {\n        this.grammar = this.props.grammar;\n        this.START_SYMBOL = this.props.startSymbol;\n\n        this.printGrammar(this.grammar);\n\n        this.buildFirstSets(this.grammar);\n        this.printSet('First sets', this.firstSets);\n\n        this.buildFollowSets(this.grammar);\n        this.printSet('Follow sets', this.followSets);\n\n        var newFirsts = this.convertSets(this.firstSets);\n        var newFollows = this.convertSets(this.followSets);\n\n        return (\n            <div className=\"tables-row\">\n                <div className=\"table-left\">\n                    <h3>Firsts Set of the grammar</h3>\n                    <br />\n                    <table className=\"first-table table table-hover table-sm\">\n                        <thead>\n                            <tr>\n                                <th scope=\"col\">#</th>\n                                <th scope=\"col\">Symbol</th>\n                                <th scope=\"col\">First Set</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            {this.setElement(this.firstSets)}\n                        </tbody>\n                    </table>\n                    <h3>Follows Set of the Grammar</h3>\n                    <br />\n                    <table className=\"follow-table table table-hover table-sm\">\n                    <thead>\n                            <tr>\n                                <th scope=\"col\">#</th>\n                                <th scope=\"col\">Symbol</th>\n                                <th scope=\"col\">Follow Set</th>\n                            </tr>\n                        </thead>\n                        <tbody>\n                            {this.setElement(this.followSets)}\n                        </tbody>\n                    </table>\n                </div>\n                <div className=\"spacer\"></div>\n                <div className=\"table-right\">\n                    <h3>Parse Table</h3>\n                    <br/>\n                    <Table \n                        grammar={this.props.grammar}\n                        firstSets={newFirsts}\n                        followSets={newFollows}\n                    ></Table>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default FirstFollow;","import React from 'react'\nimport FirstFollow from './firstfollow';\n\nimport './bootstrap.min.css';\nimport './styles.css';\n\n/*\n    {\n        1: \"A -> B\"\n    }\n*/\n\nclass LL1 extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            show: false,\n            transitions: {},\n            ll1: false,\n            startSymbol: null\n        }\n    }\n\n    getLHS = (production) => {\n        return production.split('->')[0].replace(/\\s+/g, '');\n    }\n\n    getRHS = (production) => {\n        return production.split('->')[1].replace(/\\s+/g, '');\n    }\n\n    EPSILON = \"ε\";\n\n    render() {\n        var lhsRef = React.createRef();\n        var rhsRef = React.createRef();\n        var startSymbolRef = React.createRef();\n        return (\n            <div>\n                <div className=\"title\">\n                    <div className=\"header\">\n                        <h1>LL1 Parsing Table</h1>\n                    </div>\n                </div>\n                <br />\n                <div className=\"input-section\">\n                    <div className=\"header\">\n                        <table className=\"table table-hover\">\n                            <thead>\n                                {this.state.startSymbol\n                                    ? <tr>\n                                        <th scope=\"row\">Start Symbol</th>\n                                        <td colSpan={2}>{this.state.startSymbol}</td>\n                                    </tr>\n                                    : <tr>\n                                        <th scope=\"row\">Enter Start Symbol</th>\n                                        <td>\n                                            <input\n                                                placeholder=\"Start Symbol Goes Here\"\n                                                name=\"start-symbol\"\n                                                ref={startSymbolRef}\n                                            >\n                                            </input>\n                                        </td>\n                                        <td>\n                                            <button\n                                                id=\"start-symbol-add\"\n                                                type=\"button\"\n                                                className=\"btn btn-warning\"\n                                                onClick={() => {\n                                                    if (startSymbolRef.current.value.length) {\n                                                        this.setState({\n                                                            startSymbol: startSymbolRef.current.value\n                                                        })\n                                                    } else {\n                                                        alert(\"Empty Input\")\n                                                    }\n                                                }}\n                                            >\n                                                Add\n                                            </button>\n                                        </td>\n                                    </tr>}\n                                <tr>\n                                    <th scope=\"col\">#</th>\n                                    <th scope=\"col\">LHS</th>\n                                    <th scope=\"col\">RHS</th>\n                                </tr>\n                            </thead>\n                            <tbody>\n\n                                {Object.keys(this.state.transitions).length\n                                    ? Object.keys(this.state.transitions)\n                                        .map((key) => {\n                                            return (\n                                                <tr key={key}>\n                                                    <th scope=\"row\">{key}</th>\n                                                    <td>{this.getLHS(this.state.transitions[key])}</td>\n                                                    <td>{this.getRHS(this.state.transitions[key])}</td>\n                                                </tr>\n                                            )\n                                        })\n                                    :\n                                    <tr>\n                                        <th scope=\"row\" colSpan={3}>No transitions added</th>\n                                    </tr>}\n                                {this.state.show\n                                    ? <tr>\n                                        <th scope=\"row\">\n                                            {Object.keys(this.state.transitions).length + 1}\n                                        </th>\n                                        <td><input\n                                            name=\"LHS\"\n                                            placeholder=\"LHS\"\n                                            ref={lhsRef}></input></td>\n                                        <td><input\n                                            name=\"RHS\"\n                                            placeholder=\"RHS\"\n                                            defaultValue={this.EPSILON}\n                                            ref={rhsRef}\n                                            onKeyDown={(e) => {\n                                                if (e.keyCode === 13) {\n                                                    if (lhsRef.current.value.length && rhsRef.current.value.length) {\n                                                        var tempList = this.state.transitions;\n                                                        tempList[Object.keys(this.state.transitions).length + 1] = lhsRef.current.value + ' -> ' + rhsRef.current.value\n                                                        this.setState({\n                                                            transitions: tempList,\n                                                            show: false\n                                                        })\n                                                    } else {\n                                                        this.setState({\n                                                            show: false\n                                                        })\n                                                    }\n\n                                                }\n                                            }}\n                                        ></input></td>\n                                    </tr>\n                                    : null}\n                            </tbody>\n                        </table>\n\n                        {/* <textarea \n                            placeholder=\"Enter the grammar\" \n                            ref={this.grammarRef}\n                            className=\"text-input\" \n                            rows={8} cols={40}>\n                        </textarea> */}\n                    </div>\n                    {this.state.show\n                        ?\n                        <div className=\"submit\">\n                            <button\n                                type=\"button\"\n                                className=\"btn btn-success\"\n                                onClick={() => {\n                                    if (lhsRef.current.value.length && rhsRef.current.value.length) {\n                                        var tempList = this.state.transitions;\n                                        tempList[Object.keys(this.state.transitions).length + 1] = lhsRef.current.value + ' -> ' + rhsRef.current.value\n                                        this.setState({\n                                            transitions: tempList,\n                                            show: false\n                                        })\n                                    } else {\n                                        this.setState({\n                                            show: false\n                                        })\n                                    }\n                                }}\n                            >\n                                Add this transition\n                            </button>\n                        </div>\n                        : <div className=\"submit\">\n                            <button\n                                type=\"button\"\n                                className=\"btn btn-primary\"\n                                onClick={() => {\n                                    this.setState({\n                                        show: true\n                                    })\n                                }}\n                            >Add</button>\n                            <button\n                                className=\"btn btn-success\"\n                                type=\"button\"\n                                onClick={() => {\n                                    if (Object.keys(this.state.transitions).length && this.state.startSymbol) {\n                                        console.log(this.state.transitions)\n                                        console.log(\"START SYMBOL: \" + this.state.startSymbol)\n                                        this.setState({\n                                            ll1: true\n                                        })\n                                    }\n                                    else\n                                        alert(\"Enter Grammar!\")\n                                }}\n                            >Submit</button>\n                        </div>}\n                </div>\n                <hr />\n                {this.state.ll1\n                    ? <div className=\"first-follow\">\n                        <FirstFollow grammar={this.state.transitions} startSymbol={this.state.startSymbol}></FirstFollow>\n                    </div>\n                    : null}\n            </div>\n        );\n    }\n}\n\nexport default LL1;","import React from 'react';\nimport LL1 from './Main/ll1-parser';\n// import FirstFollow from './firstfollow';\n// import './bootstrap.min';\n\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <LL1></LL1>\n      {/* <FirstFollow></FirstFollow> */}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}